---
title: 前端算法学习笔记
date: 2017-01-20 16:14:42
tags:
	- 原创
	- 前端
---

> 算法在于理解其原理，本篇记录备忘。

<!--more-->

日本程序员norahiko，写了一个排序算法的[动画演示](http://jsdo.it/norahiko/oxIy/fullscreen)，非常有趣。


# 冒泡排序

是的，先来个最简单的热热身。
原理：
（1）比较相邻两个数，如果前者大于后者，就把两个数交换位置。
（2）对每一对相邻的元素做同样的工作。

```javascript
function bubbleSort(arr){
    var len = arr.length,j;
    var temp;
    while(len > 0){
        for( j = 0; j < len - 1; j++){
            if(arr[j] > arr[j + 1]){
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        i--;
    }
    return arr;
}    
```

# 快排算法

"快速排序"的思想很简单，整个排序过程只需要三步：
（1）在数据集之中，选择一个元素作为"基准"（pivot）。
（2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
（3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

举例来说，现在有个数据集合[85, 24, 63, 45, 17, 31, 96, 50]，怎么对其排序呢？
第一步，选择中间的元素45作为"基准"。（基准值可以任意选择，但是选择中间的值比较容易理解。）
[85, 24, 63, **45**, 17, 31, 96, 50]
第二步，按照顺序，将每个元素与"基准"进行比较，形成两个子集，一个"小于45"，另一个"大于等于45"。
[24, 17, 31], **45**, [85, 63, 96, 50]
第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
[24, **17**, 31], 45, [85, **63**, 96, 50]
**17**, [24, 31], 45, [50], **63**, [85, 96]
17, [**24**, 31], 45, 50, 63, [**85**, 96]
[17, 24, 31, 45, 50, 63, 85, 96]

**具体实现**
```javascript
var a = [2,4,5,63,4,5,63,2,4,43];
 
function quicksort(arr){
    if (arr.length == 0)
        return [];
 
    var left = new Array();
    var right = new Array();
    // 基准值可取第一个，或者去中间值
    // var pivot = arr[0];
    var pivot = arr.splice(pivotIndex, 1)[0];
 
    for (var i = 1; i < arr.length; i++) {
    	// 将每个元素与”基准”进行比较，所有大于"基准"的元素，都移到"基准"的右边
        if (arr[i] < pivot) {
           left.push(arr[i]);
        } else {
           right.push(arr[i]);
        }
    }
 
 	// 递归处理快速排序，并重新合并处理后的数组
    return quicksort(left).concat(pivot, quicksort(right));
}
 
console.log(quicksort(a));
```

# 直接插入排序

原理：将无序数列中的元素插入到有序数列的对应位置，插入前通过比大小的方式找到其在有序数列中的对应位置。

```javascript
function insertSort (arr) {
    // 假设第0个元素是一个有序的数列，第1个以后的是无序的序列，
    // 所以从第1个元素开始将无序数列的元素插入到有序数列中
    for (var i = 1; i < arr.length; i++) {
        if(arr[i] < arr[i + 1]){
            var guard = arr[i]; // 取出无序数列中的第i个作为被插入元素
            var j = i - 1; // 记录有序数组最后一位下标
            arr[i] = arr[j]; // 有序数组扩大到i
            // 遍历有序数组,寻找需要插入的下标,并将有序数组往后移动
            while (j >= 0 && guard < arr[j]) {
                arr[j + 1] = arr[j];
                j--;
            }
            // 插入
            arr[j + 1] = guard;
        }
    }
}
```



















